1. flex 布局相关

  Q：怎么让一个不知道宽高的元素垂直水平居中
  A：display: flex; justify-content: center; align-items: center; 能说出来这个就算满意，
     当然不排除有其他方法，最起码 flex 是当下最主流的

2. 闭包

  Q：谈谈什么是闭包，闭包的使用场景。

  A：官方描述：闭包返回一个不被销毁的私有作用域；
     直白一点，函数外部是访问不到函数内部变量的，但是函数内部的函数可以访问到外面函数的变量，
     所以闭包的原理就是返回内部的函数给外界调用，从而访问到这个函数内部的变量；
     所谓不被销毁，是因为闭包函数返回的函数访问了闭包函数内部的变量。

     闭包的缺点：可能导致内存溢出。

     使用场景：能不用就不用。

3. js 事件循环机制

  Q：谈谈 js 的 事件循环机制（主要考察js同步任务、异步任务（微任务、宏仁务）的执行顺序）
  A：js引擎会从上到下依次解析并执行代码，当遇到同步代码，立即执行；
     当遇到异步任务，会把这些任务一次放到队列中等待执行；
     异步任务分为 宏仁务 和 微任务；
     常见的宏仁务：setTimeout/setInterval
     常见的微任务：Promise

     当同步任务执行完以后，js引擎就会去队列里面找微任务一次执行，如果微任务里面又包含异步任务，又一次放到队列中的最后面，
     当所以微任务执行完以后，就会去依次执行宏仁务，每执行完一个宏仁务，都会去检查一遍微任务队列，如果队列里有微任务，
     则执行完所有微任务，再去执行宏仁务。

     总结：js 同步异步执行顺序：
      同步任务执行完 -> （微任务执行完 -> 执行一个宏仁务 -> 检查一遍微任务队列） -> 一直循环括号内的

4. Vue 相关

  Q：双向数据绑定的原理
  A：vue 双向数据绑定是通过 数据劫持 结合 发布订阅模式的方式来实现的，也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变；

     核心：关于VUE双向数据绑定，其核心是 Object.defineProperty()方法；

  Q：Vue 组件通信
  A：props（父子组件通信）、eventBus（小项目全局状态管理）、Vuex（大项目全局状态管理），这三个是最常用的；
     
    Q：props 有没有什么要注意的
    A：单向数据流（也就是说不允许直接在子组件修改父组件的数据，想要修改，必须使用 $emit 触发父组件的传递来的事件）

    Q: eventBus 原理
    A：重新 new 了一个 Vue，使用 Vue.prototype.$on 监听事件，使用 Vue.prototype.$emit 触发事件，
       当然，也可以在new的时候传一个data（作用和Vuex中的state一样），这个data同样被 Object.defineProperty 过。

    Q：Vuex 中的 mutations 中 为什么不能异步操作数据
    A：不利于 浏览器中 Vue-devtools 调试，其他并没有什么影响。

    Q：怎么解决 页面刷新 时，Vuex 中 的数据丢失问题
    A：Vuex状态持久化

    Q：什么是状态持久化，原理又是什么？
    A：状态持久化，就是为了解决 Vuex 在浏览器刷新后的数据丢失的；
       原理：在每次 commit 的时候，将 state 中的数据存储到 localStorage 中，浏览器刷新的时候再去 localStorage 中读取数据；

      Q：状态持久化有没有需要注意的地方
      A：频繁操作 localStorage 很耗性能，所以需要在适当的时候写入，而不是每次 commit 都写入（这就是所谓的防抖）

5. Promise

  Q：Promise有没有用过，解决了什么问题
  A：从编程层面来说，解决了回调函数带来的回调地狱问题；
     从功能方面来说，可以控制不同请求的执行顺序和时机。

好了，回去等通知吧！

       